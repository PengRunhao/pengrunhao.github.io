<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>睡觉大王的博客 - 日积跬步</title><meta name="author" content="Peng Runhao"><meta name="copyright" content="Peng Runhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="千里之行，始于足下。">
<meta property="og:type" content="website">
<meta property="og:title" content="睡觉大王的博客">
<meta property="og:url" content="http://pengrunhao.github.io/page/2/index.html">
<meta property="og:site_name" content="睡觉大王的博客">
<meta property="og:description" content="千里之行，始于足下。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://pengrunhao.github.io/img/cat.jpg">
<meta property="article:author" content="Peng Runhao">
<meta property="article:tag" content="博客, 睡觉大王">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://pengrunhao.github.io/img/cat.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://pengrunhao.github.io/page/2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Peng Runhao","link":"链接: ","source":"来源: 睡觉大王的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '睡觉大王的博客',
  isPost: false,
  isHome: true,
  isHighlightShrink: true,
  isToc: false,
  postUpdate: '2025-04-16 01:14:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/cat.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/moon.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="睡觉大王的博客"><span class="site-name">睡觉大王的博客</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">睡觉大王的博客</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/11/21/%E7%94%A8%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F%E6%A0%88/" title="用队列模拟栈">用队列模拟栈</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-21T15:09:17.000Z" title="发表于 2024-11-21 23:09:17">2024-11-21</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-21T15:12:46.098Z" title="更新于 2024-11-21 23:12:46">2024-11-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="content">用队列模拟栈1.基本操作的实现思路入栈操作（push），将元素添加到非空的队列中，如果两个队列都为空，则添加到其中任意一个队列（这里假设是队列 1）。
出栈操作（pop）稍微复杂一些。我们需要把非空队列（假设是队列 1）中的元素逐个出队并放入另一个队列（队列 2），除了最后一个元素，最后一个元素就是我们要模拟出栈的元素，将其返回即可。然后交换两个队列的角色，以便后续操作。
获取栈顶元素（top）的操作与出栈类似，只是在找到栈顶元素后，我们需要把它重新放回原来的队列，以保持栈的状态不变。
判断栈是否为空（empty）则只需检查两个队列是否都为空即可。
2.C++实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;struct StackUsingQueue&#123;	queue&lt;int&gt; q1;	queue&lt;i ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/11/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92_%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" title="动态规划_背包问题">动态规划_背包问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-20T14:51:52.000Z" title="发表于 2024-11-20 22:51:52">2024-11-20</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-24T09:51:10.351Z" title="更新于 2024-12-24 17:51:10">2024-12-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="content">一、动态规划问题的思考方式
f(i, j)表示集合的某种属性，集合中是所有的选法，但属性是一个值，f(i, j)最终会落实到这个值上面。在01背包中，f(i, j)的值表示所有选法的价值的最大值。
所有的动态规划问题都可以用上图的思考方式，分别考虑状态表示是什么？状态计算是什么？状态表示是哪个集合的哪种属性？集合是哪些东西的集合？集合中的元素要满足什么条件？状态计算表示集合的划分，当前的选法可以分成哪些类？怎么把这些类算出来？
对于01背包问题:
集合是所有“从前i个物品中选的总体积不大于j的选法”的集合；
集合中的元素都满足只从前i个物品中挑选，且总体积不大于j；
状态表示是这个集合中所有选法的价值的最大值；
这些集合可以分成两大类：(a)从第1到第i个物品中选，不包含第i个物品的选法的集合。(b)从第1到第i个物品中选，包含第i个物品的选法的集合；
不包含第i个物品的所有选法的价值的最大值 = f(i-1, j); 包含第i个物品的所有选法的价值的最大值 = 去掉第i个物品后，所有选法的价值的最大值 + 第i个物品的价值w[i] = f(i-1, j-v[i])+w[i]; f(i ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/11/18/%E5%85%B3%E4%BA%8E%E6%97%A9%E7%9D%A1%E4%B8%8E%E5%91%A8%E6%9C%9F%E6%80%A7%E9%AB%98%E4%BA%A2%E5%92%8C%E4%BD%8E%E6%B2%89%E9%97%AE%E9%A2%98%E7%9A%84%E7%A0%94%E7%A9%B6/" title="《关于早睡与周期性高亢和低沉问题的研究》">《关于早睡与周期性高亢和低沉问题的研究》</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-18T13:37:41.000Z" title="发表于 2024-11-18 21:37:41">2024-11-18</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-15T02:44:33.746Z" title="更新于 2024-12-15 10:44:33">2024-12-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></span></div><div class="content">《关于早睡与周期性高亢和低沉问题的研究》简称《研究》，由于一直陷入周期性的高亢与低沉状态，高亢时动力满满，低沉时习惯性熬夜晚睡，实在不是长久之计且身心俱疲，故有此研究。本研究旨在通过自我的思考与实践，得出一种同时满足本人物质需求与精神需求的生活方式。
0.早睡与早起早起是以早睡为前提的，所以一切的问题只在于早睡，在于晚上拒绝手机与电脑的影响，养成稳定的生物钟，每晚到点上床入眠，做到早睡，早起则板上钉钉。从而使得每一天都清醒且有效率。
1.早睡的切实益处a.时间的极大充裕早睡使我的生活达到一种规律的可持续的状态，可供我支配的时间远远大于之前周期性高亢与低沉的生活中可支配的时间，此为最主要原因。
时间就其本质而言，就等同于生命本身，时间的流逝亦是生命的流逝，Time’s precious. Don’t fuckin’ waste it. 逝去的每一天都不再来，尽力的感受每一分钟吧。
b.改善一直以来做事不能持续的问题。以看书为例，时常在经历一两个高亢与低沉的周期之后，会不自觉的忘记之前的看书时间与看书习惯，等到再想起时已经相差数日。做事不能持续一直以来是我最难以改正的恶习，通过每日的早睡， ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/11/17/%E5%85%B1%E4%BA%AB%E6%A0%88/" title="共享栈">共享栈</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-17T15:28:31.000Z" title="发表于 2024-11-17 23:28:31">2024-11-17</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-17T15:41:47.419Z" title="更新于 2024-11-17 23:41:47">2024-11-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="content">共享栈C++类的实现方式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;const int MaxSize = 100;  // 定义共享栈的最大容量 class SharedStack&#123;private:	int data[MaxSize];	int top1;	int top2;public:	// 构造函数，用于初始化栈顶指针,在创建类的对象时自动调用 	SharedStack()&#123;		top1 = -1;		top2 = MaxSize;	&#125;		// 共享栈判满 	bool isFull()  	&#123;		return top1 + 1 == top2; 	&#125;		//第一个栈的入栈操作 	bool push1(int ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/11/16/%E7%94%A8%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97/" title="用栈模拟队列">用栈模拟队列</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-16T15:45:34.000Z" title="发表于 2024-11-16 23:45:34">2024-11-16</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-16T15:49:16.141Z" title="更新于 2024-11-16 23:49:16">2024-11-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="content">用栈模拟队列思路我们使用两个栈 stack1 和 stack2 来模拟队列的操作。stack1 主要用于入队操作，就像是队列的尾部，新元素不断地被压入到 stack1 中。stack2 主要用于出队操作，它在需要出队时扮演着队列头部的角色。
入队操作（push）
当执行入队操作时，直接将元素压入到 stack1 中即可。因为栈的特性是后进先出，对于入队来说，我们只需要按照顺序依次把新元素放到 “队尾”（也就是 stack1 的栈顶位置）就可以了，这个操作很简单。

出队操作（pop）
当要执行出队操作时，首先需要判断 stack2 是否为空。
如果 stack2 为空，那就意味着之前出队操作已经把 stack2 中的元素都处理完了，此时需要将 stack1 中的元素全部转移到 stack2 中。转移的过程就是不断地把 stack1 的栈顶元素弹出并压入到 stack2 中。这样做的目的是为了让 stack2 中的元素顺序和队列的出队顺序一致（先进先出），因为 stack1 中的元素顺序和队列入队顺序是相反的，经过这么一倒腾，就符合队列出队的要求了。这个转移操作的时间复杂度是 O(n)， ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/11/08/C-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BC%A0%E5%8F%82/" title="C++二维数组的传参">C++二维数组的传参</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-07T16:32:27.000Z" title="发表于 2024-11-08 00:32:27">2024-11-08</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-07T17:02:34.161Z" title="更新于 2024-11-08 01:02:34">2024-11-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="content">C++二维数组的传参第一种：给定第二维长度的二维数组作为形参传递12345678910111213int sum(int arr[][3], int row, int col)&#123;	int res = 0;	for(int i = 0; i &lt; row ; i ++) 		for(int j = 0; j &lt; col; j ++)		res += arr[i][j];	return res;&#125;int main() &#123;	int arr[3][3] = &#123;&#123;1, 2, 3&#125;,&#123;1, 3, 2&#125;, &#123;1, 5, 7&#125;&#125;;	printf(&quot;%d &quot;, sum(arr, 3, 3));&#125; 
缺点：必须事先给出第二维的长度，即不是对任意大小的二维数组都适用。
第二种：指针形式传参1234567891011121314int sum(int *arr, int row, int col)&#123;	int res = 0;	for(int i = 0 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/11/02/C-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/" title="C++链表的定义与初始化">C++链表的定义与初始化</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-02T15:11:47.000Z" title="发表于 2024-11-02 23:11:47">2024-11-02</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-02T15:29:14.790Z" title="更新于 2024-11-02 23:29:14">2024-11-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="content">C++链表的定义与初始化结构体结点的定义1234567struct ListNode&#123;	int val;	ListNode *next;    ListNode(): val(0), next(nullptr) &#123;&#125;;    ListNode(int x): val(x), next(nullptr) &#123;&#125;;    ListNode(int x, ListNode *next): val(x), next(next) &#123;&#125;;&#125;;
初始化指针1ListNode *p = nullptr;
初始化结点12345ListNode *node1 = new ListNode();    // 初始化一个名为node1的结点，其val值默认为0，next指向nullptrListNode *node2 = new ListNode(2);   // 初始化一个名为node2的结点，其val值为2，next指向nullptrListNode *node3 = new ListNode(5, node2); // 初始化 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/10/12/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80_%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/" title="算法基础_前缀和与差分">算法基础_前缀和与差分</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-12T07:32:27.000Z" title="发表于 2024-10-12 15:32:27">2024-10-12</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-24T12:45:00.483Z" title="更新于 2024-12-24 20:45:00">2024-12-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="content">前缀和与差分前缀和与差分是一对逆运算。
一、前缀和数组前缀和数组的定义：
若有一个原数组a[N]，前缀和数组S[i]定义为：数组a的前i个元素之和。

s[i] = a[1] + a[2] + ... +a[i],  其中s[0] = 0.注意：前缀和数组的下标一定要从1开始。
如何求前缀和数组S[i]?
 for(int i = 1; i &lt;= n; i ++ ) s[i] = s[i-1] + a[i];
前缀和数组S[i]的作用
 快速的求出原数组中一段数的和。例如：a[l, r] = s[r] - s[l-1]
为什么前缀和数组的下标要从1开始，且定义S[0] = 0
统一操作，更好处理边界问题。如上一个问题中的s[l - 1]，当l = 1时，需要S[0]。
二、差分数组差分数组的定义：
若有数组a[1], a[2], ... ,a[n]，构造b[]数组，使得：

a[i] = b[1] + b[2] + ... + b[i]称数组b[]是数组a[]的差分数组。
构造方式：

b[1] = a[1]\\
b[2] = a[2] - a[1]\\
...\\
b[i] = ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/10/11/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80_%E9%AB%98%E7%B2%BE%E5%BA%A6/" title="算法基础_高精度">算法基础_高精度</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-11T06:35:28.000Z" title="发表于 2024-10-11 14:35:28">2024-10-11</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-24T12:24:59.106Z" title="更新于 2024-12-24 20:24:59">2024-12-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="content">高精度本章的高精度算法主要有四种：

A + B，大整数加法
A - B，大整数减法
A * b，大整数乘以一个相对较小的数
A / b，大整数除以一个相对较小的数

数的具体范围如下图：

大整数的存储：主要通过数组来存储，其中地址为0的位置存储大整数的个位，数字的高地址存储大整数的高位。
A+B123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)   // 传入引用类型，速度更快&#123;        vector&lt;int&gt; C;  // C = A + B        int t = 0;  // 进位,初始时进位为0    for(int i = 0; i &lt; A.size() || i &lt; B.s ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/10/09/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80_%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" title="算法基础_二分查找">算法基础_二分查找</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-09T06:45:18.000Z" title="发表于 2024-10-09 14:45:18">2024-10-09</time><span class="article-meta-separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-24T12:23:14.206Z" title="更新于 2024-12-24 20:23:14">2024-12-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="content">一、整数二分整数二分的本质：1.二分与单独性的关系：有单调性的题目一定可以二分，但有些没有单调性的题目也可以用二分来解决。故二分的本质并不是单调性。
2.如果有一种性质，使得整个区间一半满足这种性质，另一半不满足这种性质，那二分就可以找到这种性质的边界。（既可以找到满足这种性质的区间的边界，也可以找到不满足这种性质的边界。）

3.整数二分的本质思想：在一个区间里面寻找答案(或者边界)，每次二分将区间分为两个，选择答案所在的区间进行下一次的二分，抛弃另一半没有答案的区间，不断重复这个过程。所以每一次选择的区间都有答案，直到这个区间的长度变为1。
4.二分一定是有解的，最后一定是有一个结果的，无解是题目有可能无解。
具体而言，整数二分有两套模板。
首先看找红色边界的模板：
mid = (l + r ) / 2
check(mid)   如果是true，那么mid在红色区间内，则红色性质的边界点在[mid, r]内(包含mid)，更新l = mid；如果是false，那么mid在绿色区间内，则红色性质的边界点的在[l, mid-1]内(mid本身不符合，故不包含mid)，更新r = mid ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><a class="page-number" href="/page/4/#content-inner">4</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/cat.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Peng Runhao</div><div class="author-info__description">千里之行，始于足下。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/16/Leetcode146-LRU%E7%BC%93%E5%AD%98/" title="Leetcode146.LRU缓存">Leetcode146.LRU缓存</a><time datetime="2025-04-15T16:22:23.000Z" title="发表于 2025-04-16 00:22:23">2025-04-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/14/%E4%BA%A4%E5%8F%89%E7%86%B5%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/" title="交叉熵损失函数">交叉熵损失函数</a><time datetime="2025-04-14T14:24:14.000Z" title="发表于 2025-04-14 22:24:14">2025-04-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/12/Leetcode3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/" title="Leetcode3.无重复字符的最长子串">Leetcode3.无重复字符的最长子串</a><time datetime="2025-04-11T17:57:11.000Z" title="发表于 2025-04-12 01:57:11">2025-04-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/" title="算法基础_双指针算法">算法基础_双指针算法</a><time datetime="2024-12-25T02:20:26.000Z" title="发表于 2024-12-25 10:20:26">2024-12-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/08/%E9%80%86%E8%BD%AC%E6%95%B0%E5%AD%97-%E7%94%A8%E6%A0%88%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B/" title="逆转数字_用栈模拟系统递归过程">逆转数字_用栈模拟系统递归过程</a><time datetime="2024-12-08T06:01:29.000Z" title="发表于 2024-12-08 14:01:29">2024-12-08</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/DL/"><span class="card-category-list-name">DL</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/"><span class="card-category-list-name">生活</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"><span class="card-category-list-name">算法题</span><span class="card-category-list-count">28</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E8%80%83%E7%A0%94/"><span class="card-category-list-name">考研</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/"><span class="card-category-list-name">随便写写</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/dfs-csdn/" style="font-size: 1.1em; color: #999">dfs, csdn</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-csdn/" style="font-size: 1.1em; color: #999">贪心算法, csdn</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 1.1em; color: #999">数据结构, 单调栈</a> <a href="/tags/csdn-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.1em; color: #999">csdn, 数据结构</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/" style="font-size: 1.1em; color: #999">深度学习, 参数设置</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E8%A7%86%E5%8C%96/" style="font-size: 1.1em; color: #999">深度学习, 可视化</a> <a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 1.1em; color: #999">云服务器，深度学习</a> <a href="/tags/%E6%95%B0%E5%AD%A6-%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/" style="font-size: 1.1em; color: #999">数学 数列极限</a> <a href="/tags/some-mid-night-thinking/" style="font-size: 1.1em; color: #999">some mid-night thinking</a> <a href="/tags/csdn-%E8%BD%AC%E7%A7%BB/" style="font-size: 1.1em; color: #999">csdn, 转移</a> <a href="/tags/%E6%A0%88-csdn/" style="font-size: 1.1em; color: #999">栈, csdn</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><span class="card-archive-list-count">8</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><span class="card-archive-list-count">13</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">38</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-04-15T17:14:32.571Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Peng Runhao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>